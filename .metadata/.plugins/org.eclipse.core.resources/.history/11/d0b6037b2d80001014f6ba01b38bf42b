#include "lcd.h"
#include <string.h>

/* ====== Private state ====== */
static uint16_t _w  = ST7735_WIDTH;
static uint16_t _h  = ST7735_HEIGHT;
static uint8_t  _rot = 0;

/* ====== Public legacy globals (expected by gui.c) ====== */
_lcd_dev  lcddev = {
    .width  = ST7735_WIDTH,
    .height = ST7735_HEIGHT,
    .id     = 0x7735,
    .dir    = 0, /* 0: portrait, 1: landscape */
};

/* Current drawing colors used by GUI text primitives */
uint16_t POINT_COLOR = WHITE;
uint16_t BACK_COLOR  = BLACK;

/* ====== Short GPIO helpers (pins/macros from main.h) ====== */
#define CS_LO()   HAL_GPIO_WritePin(LCD_CS_GPIO_Port,  LCD_CS_Pin,  GPIO_PIN_RESET)
#define CS_HI()   HAL_GPIO_WritePin(LCD_CS_GPIO_Port,  LCD_CS_Pin,  GPIO_PIN_SET)
#define DC_LO()   HAL_GPIO_WritePin(LCD_DC_GPIO_Port,  LCD_DC_Pin,  GPIO_PIN_RESET)
#define DC_HI()   HAL_GPIO_WritePin(LCD_DC_GPIO_Port,  LCD_DC_Pin,  GPIO_PIN_SET)
#define RST_LO()  HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_RESET)
#define RST_HI()  HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_SET)

#ifdef LCD_BL_Pin
  #define BL_ON()   HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET)
  #define BL_OFF()  HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_RESET)
#else
  #define BL_ON()   ((void)0)
  #define BL_OFF()  ((void)0)
#endif

/* ====== SPI helpers ====== */
extern SPI_HandleTypeDef hspi1;

static inline void wr8(uint8_t d) {
  HAL_SPI_Transmit(&hspi1, &d, 1, HAL_MAX_DELAY);
}
static inline void wr16(uint16_t d) {
  uint8_t b[2] = { (uint8_t)(d >> 8), (uint8_t)(d & 0xFF) };
  HAL_SPI_Transmit(&hspi1, b, 2, HAL_MAX_DELAY);
}
static inline void cmd(uint8_t c) {
  DC_LO(); CS_LO(); wr8(c); CS_HI();
}
static inline void data8(uint8_t d) {
  DC_HI(); CS_LO(); wr8(d); CS_HI();
}
static inline void data16_rep(uint16_t color, uint32_t count) {
  DC_HI(); CS_LO();
  uint8_t b[2] = { (uint8_t)(color>>8), (uint8_t)color };
  while (count--) HAL_SPI_Transmit(&hspi1, b, 2, HAL_MAX_DELAY);
  CS_HI();
}

static void hw_reset(void) {
  RST_LO(); HAL_Delay(50);
  RST_HI(); HAL_Delay(120);
}

/* ====== Address window (private) ====== */
static void set_window(uint16_t xs, uint16_t ys, uint16_t xe, uint16_t ye) {
  xs += ST7735_XSTART; xe += ST7735_XSTART;
  ys += ST7735_YSTART; ye += ST7735_YSTART;

  cmd(0x2A);
  data8(xs >> 8); data8(xs & 0xFF);
  data8(xe >> 8); data8(xe & 0xFF);

  cmd(0x2B);
  data8(ys >> 8); data8(ys & 0xFF);
  data8(ye >> 8); data8(ye & 0xFF);

  cmd(0x2C); /* RAMWR */
}

/* ====== MADCTL (orientation) ====== */
static void set_madctl_by_rot(uint8_t rot) {
  uint8_t madctl;
  switch (rot & 3) {
    case 0: madctl = 0xC0; _w = ST7735_WIDTH;  _h = ST7735_HEIGHT;  lcddev.dir = 0; break; // MX|MY|BGR
    case 1: madctl = 0xA0; _w = ST7735_HEIGHT; _h = ST7735_WIDTH;   lcddev.dir = 1; break; // MV|MY|BGR
    case 2: madctl = 0x00; _w = ST7735_WIDTH;  _h = ST7735_HEIGHT;  lcddev.dir = 0; break; // (BGR=0)
    default:madctl = 0x60; _w = ST7735_HEIGHT; _h = ST7735_WIDTH;   lcddev.dir = 1; break; // MV|MX
  }
  cmd(0x36); data8(madctl);

  /* Keep legacy struct in sync */
  lcddev.width  = _w;
  lcddev.height = _h;
}

/* ====== Public API ====== */

void LCD_Backlight_On(void)  { BL_ON();  }
void LCD_Backlight_Off(void) { BL_OFF(); }

uint16_t LCD_Width(void)  { return _w; }
uint16_t LCD_Height(void) { return _h; }

void LCD_SetRotation(uint8_t r) {
  _rot = (uint8_t)(r & 3);
  set_madctl_by_rot(_rot);
}

void LCD_Init(void) {
  BL_OFF();
  hw_reset();

  cmd(0x11);                     // Sleep out
  HAL_Delay(120);

  // Frame rate control
  cmd(0xB1); data8(0x01); data8(0x2C); data8(0x2D);
  cmd(0xB2); data8(0x01); data8(0x2C); data8(0x2D);
  cmd(0xB3); data8(0x01); data8(0x2C); data8(0x2D);
             data8(0x01); data8(0x2C); data8(0x2D);

  cmd(0xB4); data8(0x07);        // Inversion

  // Power sequence
  cmd(0xC0); data8(0xA2); data8(0x02); data8(0x84);
  cmd(0xC1); data8(0xC5);
  cmd(0xC2); data8(0x0A); data8(0x00);
  cmd(0xC3); data8(0x8A); data8(0x2A);
  cmd(0xC4); data8(0x8A); data8(0xEE);
  cmd(0xC5); data8(0x0E);        // VCOM

  // Orientation (rotation 0 by default)
  set_madctl_by_rot(0);

  // Gamma
  cmd(0xE0);
  data8(0x0F); data8(0x1A); data8(0x0F); data8(0x18);
  data8(0x2F); data8(0x28); data8(0x20); data8(0x22);
  data8(0x1F); data8(0x1B); data8(0x23); data8(0x37);
  data8(0x00); data8(0x07); data8(0x02); data8(0x10);

  cmd(0xE1);
  data8(0x0F); data8(0x1B); data8(0x0F); data8(0x17);
  data8(0x33); data8(0x2C); data8(0x29); data8(0x2E);
  data8(0x30); data8(0x30); data8(0x39); data8(0x3F);
  data8(0x00); data8(0x07); data8(0x03); data8(0x10);

  // Column/Row range to full
  cmd(0x2A); data8(0x00); data8(0x00); data8(0x00); data8(0x7F); // X: 0..127
  cmd(0x2B); data8(0x00); data8(0x00); data8(0x00); data8(0x9F); // Y: 0..159

  // Pixel format: 16-bit
  cmd(0x3A); data8(0x05);

  cmd(0x29);                     // Display on

  BL_ON();

  /* Sync legacy struct in case someone reads before drawing */
  lcddev.width  = _w;
  lcddev.height = _h;

  LCD_Clear(BLACK);
}

void LCD_Clear(uint16_t color) {
  set_window(0, 0, _w - 1, _h - 1);
  data16_rep(color, (uint32_t)_w * _h);
}

void LCD_DrawPixel(uint16_t x, uint16_t y, uint16_t color) {
  if (x >= _w || y >= _h) return;
  set_window(x, y, x, y);
  DC_HI(); CS_LO(); wr16(color); CS_HI();
}

void LCD_FillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
  if (x >= _w || y >= _h) return;
  if (x + w > _w) w = _w - x;
  if (y + h > _h) h = _h - y;
  set_window(x, y, x + w - 1, y + h - 1);
  data16_rep(color, (uint32_t)w * h);
}

void LCD_DrawFastHLine(uint16_t x, uint16_t y, uint16_t w, uint16_t color) {
  if (y >= _h || x >= _w) return;
  if (x + w > _w) w = _w - x;
  set_window(x, y, x + w - 1, y);
  data16_rep(color, w);
}

void LCD_DrawFastVLine(uint16_t x, uint16_t y, uint16_t h, uint16_t color) {
  if (x >= _w || y >= _h) return;
  if (y + h > _h) h = _h - y;
  set_window(x, y, x, y + h - 1);
  data16_rep(color, h);
}

void LCD_DrawImage565(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t *pixels) {
  if (x >= _w || y >= _h) return;
  if (x + w > _w) w = _w - x;
  if (y + h > _h) h = _h - y;

  set_window(x, y, x + w - 1, y + h - 1);

  DC_HI(); CS_LO();
  /* transmit as bytes (big-endian) */
  for (uint32_t i = 0; i < (uint32_t)w * h; ++i) {
    uint16_t px = pixels[i];
    uint8_t b[2] = { (uint8_t)(px >> 8), (uint8_t)px };
    HAL_SPI_Transmit(&hspi1, b, 2, HAL_MAX_DELAY);
  }
  CS_HI();
}

/* ====== Legacy compatibility wrappers ======
 * These provide the symbols your existing GUI code calls.
 */

void LCD_SetCursor(uint16_t x, uint16_t y) {
  if (x >= _w || y >= _h) return;
  set_window(x, y, x, y);  /* also issues RAMWR */
}

void LCD_SetWindows(uint16_t sx, uint16_t sy, uint16_t ex, uint16_t ey) {
  /* clip to bounds to be safe */
  if (sx >= _w) sx = _w - 1;
  if (sy >= _h) sy = _h - 1;
  if (ex >= _w) ex = _w - 1;
  if (ey >= _h) ey = _h - 1;
  if (ex < sx) ex = sx;
  if (ey < sy) ey = sy;
  set_window(sx, sy, ex, ey);    /* also issues RAMWR */
}

void Lcd_WriteData_16Bit(uint16_t color) {
  /* assumes a prior LCD_SetCursor/LCD_SetWindows (RAMWR already sent) */
  DC_HI(); CS_LO(); wr16(color); CS_HI();
}

void LCD_DrawPoint(uint16_t x, uint16_t y) {
  LCD_DrawPixel(x, y, POINT_COLOR);
}
