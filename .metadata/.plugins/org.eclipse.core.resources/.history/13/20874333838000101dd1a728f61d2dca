#include "lcd.h"
#include <string.h>

/* ====== Private state ====== */
static uint16_t _w  = ST7735_WIDTH;
static uint16_t _h  = ST7735_HEIGHT;
static uint8_t  _rot = 0;

/* ====== Public legacy globals (expected by gui.c) ====== */
_lcd_dev  lcddev = {
    .width  = ST7735_WIDTH,
    .height = ST7735_HEIGHT,
    .id     = 0x7735,
    .dir    = 0, /* 0: portrait, 1: landscape */
};

/* Current drawing colors used by GUI text primitives */
uint16_t POINT_COLOR = WHITE;
uint16_t BACK_COLOR  = BLACK;

/* ====== Short GPIO helpers (pins/macros from main.h) ====== */
#define CS_LO()   HAL_GPIO_WritePin(LCD_CS_GPIO_Port,  LCD_CS_Pin,  GPIO_PIN_RESET)
#define CS_HI()   HAL_GPIO_WritePin(LCD_CS_GPIO_Port,  LCD_CS_Pin,  GPIO_PIN_SET)
#define DC_LO()   HAL_GPIO_WritePin(LCD_DC_GPIO_Port,  LCD_DC_Pin,  GPIO_PIN_RESET)
#define DC_HI()   HAL_GPIO_WritePin(LCD_DC_GPIO_Port,  LCD_DC_Pin,  GPIO_PIN_SET)
#define RST_LO()  HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_RESET)
#define RST_HI()  HAL_GPIO_WritePin(LCD_RST_GPIO_Port, LCD_RST_Pin, GPIO_PIN_SET)

#ifdef LCD_BL_Pin
  #define BL_ON()   HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET)
  #define BL_OFF()  HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_RESET)
#else
  #define BL_ON()   ((void)0)
  #define BL_OFF()  ((void)0)
#endif

/* ====== SPI helpers ====== */
extern SPI_HandleTypeDef hspi1;

static inline void wr8(uint8_t d) {
  HAL_SPI_Transmit(&hspi1, &d, 1, HAL_MAX_DELAY);
}
static inline void wr16(uint16_t d) {
  uint8_t b[2] = { (uint8_t)(d >> 8), (uint8_t)(d & 0xFF) };
  HAL_SPI_Transmit(&hspi1, b, 2, HAL_MAX_DELAY);
}
static inline void cmd(uint8_t c) {
  DC_LO(); CS_LO(); wr8(c); CS_HI();
}
static inline void data8(uint8_t d) {
  DC_HI(); CS_LO(); wr8(d); CS_HI();
}
static inline void data16_rep(uint16_t color, uint32_t count) {
  DC_HI(); CS_LO();
  uint8_t b[2] = { (uint8_t)(color>>8), (uint8_t)color };
  while (count--) HAL_SPI_Transmit(&hspi1, b, 2, HAL_MAX_DELAY);
  CS_HI();
}

static void hw_reset(void) {
  RST_LO(); HAL_Delay(50);
  RST_HI(); HAL_Delay(120);
}

/* ====== Address window (private) ====== */
static void set_window(uint16_t xs, uint16_t ys, uint16_t xe, uint16_t ye) {
  xs += ST7735_XSTART; xe += ST7735_XSTART;
  ys += ST7735_YSTART; ye += ST7735_YSTART;

  cmd(0x2A);
  data8(xs >> 8); data8(xs & 0xFF);
  data8(xe >> 8); data8(xe & 0xFF);

  cmd(0x2B);
  data8(ys >> 8); data8(ys & 0xFF);
  data8(ye >> 8); data8(ye & 0xFF);

  cmd(0x2C); /* RAMWR */
}

/* ====== MADCTL (orientation) ====== */
static void set_madctl_by_rot(uint8_t rot) {
  uint8_t madctl;
  switch (rot & 3) {
    case 0: madctl = 0xC0; _w = ST7735_WIDTH;  _h = ST7735_HEIGHT;  lcddev.dir = 0; break; // MX|MY|BGR
    case 1: madctl = 0xA0; _w = ST7735_HEIGHT; _h = ST7735_WIDTH;   lcddev.dir = 1; break; // MV|MY|BGR
    case 2: madctl = 0x00; _w = ST7735_WIDTH;  _h = ST7735_HEIGHT;  lcddev.dir = 0; break; // (BGR=0)
    default:madctl = 0x60; _w = ST7735_HEIGHT; _h = ST7735_WIDTH;   lcddev.dir = 1; break; // MV|MX
  }
  cmd(0x36); data8(madctl);

  /* Keep legacy struct in sync */
  lcddev.width  = _w;
  lcddev.height = _h;
}

/* ====== Public API ====== */

void LCD_Backlight_On(void)  { BL_ON();  }
void LCD_Backlight_Off(void) { BL_OFF(); }

uint16_t LCD_Width(void)  { return _w; }
uint16_t LCD_Height(void) { return _h; }

void LCD_SetRotation(uint8_t r) {
  _rot = (uint8_t)(r & 3);
  set_madctl_by_rot(_rot);
}

void LCD_Init(void) {
  BL_OFF();
  hw_reset();

  cmd(0x11);                     // Sleep out
  HAL_Delay(120);

  // Frame rate control
  cmd(0xB1); data8(0x01); data8(0x2C); data8(0x2D);
  cmd(0xB2); data8(0x01); data8(0x2C); data8(0x2D);
  cmd(0xB3); data8(0x01); data8(0x2C); data8(0x2D);
             data8(0x01); data8(0x2C); data8(0x2D);

  cmd(0xB4); data8(0x07);        // Inversion

  // Power sequence
  cmd(0xC0); data8(0xA2); data8(0x02); data8(0x84);
  cmd(0xC1); data8(0xC5);
  cmd(0xC2); data8(0x0A); data8(0x00);
  cmd(0xC3); data8(0x8A); data8(0x2A);
  cmd(0xC4); data8(0x8A); data8(0xEE);
  cmd(0xC5); data8(0x0E);        // VCOM

  // Orientation (rotation 0 by default)
  set_madctl_by_rot(0);

  // Gamma
  cmd(0xE0);
  data8(0x0F); data8(0x1A); data8(0x0F); data8(0x18);
  data8(0x2F); data8(0x28); data8(0x20); data8(0x22);
  data8(0x1F); data8(0x1B); data8(0x23); data8(0x37);
  data8(0x00); data8(0x07); data8(0x02); data8(0x10);

  cmd(0xE1);
  data8(0x0F); data8(0x1B); data8(0x0F); data8(0x17);
  data8(0x33); data8(0x2C); data8(0x29); data8(0x2E);
  data8(0x30); data8(0x30); data8(0x39); data8(0x3F);
  data8(0x00); data8(0x07); data8(0x03); data8(0x10);

  // Column/Row range to full
  cmd(0x2A); data8(0x00); data8(0x00); data8(0x00); data8(0x7F); // X: 0..127
  cmd(0x2B); data8(0x00); data8(0x00); data8(0x00); data8(0x9F); // Y: 0..159

  // Pixel format: 16-bit
  cmd(0x3A); data8(0x05);

  cmd(0x29);                     // Display on

  BL_ON();

  /* Sync legacy struct in case someone reads before drawing */
  lcddev.width  = _w;
  lcddev.height = _h;

  LCD_Clear(BLACK);
}

void LCD_Clear(uint16_t color) {
  set_window(0, 0, _w - 1, _h - 1);
  data16_rep(color, (uint32_t)_w * _h);
}

void LCD_DrawPixel(uint16_t x, uint16_t y, uint16_t color) {
  if (x >= _w || y >= _h) return;
  set_window(x, y, x, y);
  DC_HI(); CS_LO(); wr16(color); CS_HI();
}

void LCD_FillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color) {
  if (x >= _w || y >= _h) return;
  if (x + w > _w) w = _w - x;
  if (y + h > _h) h = _h - y;
  set_window(x, y, x + w - 1, y + h - 1);
  data16_rep(color, (uint32_t)w * h);
}

void LCD_DrawFastHLine(uint16_t x, uint16_t y, uint16_t w, uint16_t color) {
  if (y >= _h || x >= _w) return;
  if (x + w > _w) w = _w - x;
  set_window(x, y, x + w - 1, y);
  data16_rep(color, w);
}

void LCD_DrawFastVLine(uint16_t x, uint16_t y, uint16_t h, uint16_t color) {
  if (x >= _w || y >= _h) return;
  if (y + h > _h) h = _h - y;
  set_window(x, y, x, y + h - 1);
  data16_rep(color, h);
}

void LCD_DrawImage565(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t *pixels) {
  if (x >= _w || y >= _h) return;
  if (x + w > _w) w = _w - x;
  if (y + h > _h) h = _h - y;

  set_window(x, y, x + w - 1, y + h - 1);

  DC_HI(); CS_LO();
  /* transmit as bytes (big-endian) */
  for (uint32_t i = 0; i < (uint32_t)w * h; ++i) {
    uint16_t px = pixels[i];
    uint8_t b[2] = { (uint8_t)(px >> 8), (uint8_t)px };
    HAL_SPI_Transmit(&hspi1, b, 2, HAL_MAX_DELAY);
  }
  CS_HI();
}

/* ====== Legacy compatibility wrappers ======
 * These provide the symbols your existing GUI code calls.
 */

void LCD_SetCursor(uint16_t x, uint16_t y) {
  if (x >= _w || y >= _h) return;
  set_window(x, y, x, y);  /* also issues RAMWR */
}

void LCD_SetWindows(uint16_t sx, uint16_t sy, uint16_t ex, uint16_t ey) {
  /* clip to bounds to be safe */
  if (sx >= _w) sx = _w - 1;
  if (sy >= _h) sy = _h - 1;
  if (ex >= _w) ex = _w - 1;
  if (ey >= _h) ey = _h - 1;
  if (ex < sx) ex = sx;
  if (ey < sy) ey = sy;
  set_window(sx, sy, ex, ey);    /* also issues RAMWR */
}

void Lcd_WriteData_16Bit(uint16_t color) {
  /* assumes a prior LCD_SetCursor/LCD_SetWindows (RAMWR already sent) */
  DC_HI(); CS_LO(); wr16(color); CS_HI();
}

void LCD_DrawPoint(uint16_t x, uint16_t y) {
  LCD_DrawPixel(x, y, POINT_COLOR);
}
/* Draw one ASCII char using 6x12 or 8x16 table.
 * size must be 12 (6x12) or 16 (8x16).
 * mode: 0 = solid (draw background pixels), 1 = transparent.
 */
static void draw_ascii(uint16_t x, uint16_t y, uint8_t ch,
                       uint8_t size, uint16_t fc, uint16_t bc, uint8_t mode)
{
    if (ch < ' ' || ch > '~') return;      // supported: 0x20..0x7E
    uint8_t idx = (uint8_t)(ch - ' ');

    if (size == 16) {
        // 8x16 font: 16 rows, 8 bits per row (1 byte per row)
        for (uint8_t row = 0; row < 16; row++) {
            uint8_t temp = asc2_1608[idx][row];
            // The original tables are LSB→left; keep the same bit order
            for (uint8_t col = 0; col < 8; col++) {
                if (temp & 0x01) {
                    LCD_DrawPixel((uint16_t)(x + col), (uint16_t)(y + row), fc);
                } else if (mode == 0) {
                    LCD_DrawPixel((uint16_t)(x + col), (uint16_t)(y + row), bc);
                }
                temp >>= 1;
            }
        }
    } else if (size == 12) {
        // 6x12 font: 12 rows, 6 bits per row (stored still in 1 byte, use low 6 bits)
        for (uint8_t row = 0; row < 12; row++) {
            uint8_t temp = asc2_1206[idx][row];
            for (uint8_t col = 0; col < 6; col++) {
                if (temp & 0x01) {
                    LCD_DrawPixel((uint16_t)(x + col), (uint16_t)(y + row), fc);
                } else if (mode == 0) {
                    LCD_DrawPixel((uint16_t)(x + col), (uint16_t)(y + row), bc);
                }
                temp >>= 1;
            }
        }
    } else {
        // Unsupported size → default to 8x16
        for (uint8_t row = 0; row < 16; row++) {
            uint8_t temp = asc2_1608[idx][row];
            for (uint8_t col = 0; col < 8; col++) {
                if (temp & 0x01) {
                    LCD_DrawPixel((uint16_t)(x + col), (uint16_t)(y + row), fc);
                } else if (mode == 0) {
                    LCD_DrawPixel((uint16_t)(x + col), (uint16_t)(y + row), bc);
                }
                temp >>= 1;
            }
        }
    }
}

static uint32_t mypow10(uint8_t n)
{
    uint32_t r = 1U;
    while (n--) r *= 10U;
    return r;
}

void LCD_ShowChar(uint16_t x,uint16_t y,uint16_t fc, uint16_t bc,
                  uint8_t ch, uint8_t size, uint8_t mode)
{
    draw_ascii(x, y, ch, size, fc, bc, mode);
}

void LCD_ShowString(uint16_t x, uint16_t y, uint8_t size,
                    const uint8_t *p, uint8_t mode)
{
    uint16_t cursor_x = x;
    uint16_t cursor_y = y;
    uint8_t step = (size == 12) ? 6 : 8;

    while (*p >= ' ' && *p <= '~') {
        if (*p == '\n') { cursor_y += size; cursor_x = x; p++; continue; }
        LCD_ShowChar(cursor_x, cursor_y, POINT_COLOR, BACK_COLOR, *p, size, mode);
        cursor_x = (uint16_t)(cursor_x + step);
        p++;
        if (cursor_x + step > LCD_Width()) { cursor_y += size; cursor_x = x; }
        if (cursor_y + size > LCD_Height()) break;
    }
}

void LCD_ShowNum(uint16_t x, uint16_t y, uint32_t num, uint8_t len, uint8_t size)
{
    uint8_t step = (size == 12) ? 6 : 8;
    uint8_t started = 0;

    for (uint8_t i = 0; i < len; i++) {
        uint32_t p10 = mypow10((uint8_t)(len - i - 1));
        uint8_t digit = (uint8_t)((num / p10) % 10U);

        if (!started && i < len - 1 && digit == 0) {
            LCD_ShowChar((uint16_t)(x + i * step), y, POINT_COLOR, BACK_COLOR, ' ', size, 0);
        } else {
            started = 1;
            LCD_ShowChar((uint16_t)(x + i * step), y, POINT_COLOR, BACK_COLOR, (uint8_t)('0' + digit), size, 0);
        }
    }
}

void LCD_Show2Num(uint16_t x,uint16_t y,uint16_t num,uint8_t len,uint8_t size,uint8_t mode)
{
    uint8_t step = (size == 12) ? 6 : 8;
    for (int i = len - 1; i >= 0; --i) {
        uint8_t digit = (uint8_t)((num / mypow10((uint8_t)i)) % 10U);
        LCD_ShowChar((uint16_t)(x + (len - 1 - i) * step), y,
                     POINT_COLOR, BACK_COLOR, (uint8_t)('0' + digit), size, mode);
    }
}

/* Center ASCII string horizontally on line y. */
void Gui_StrCenter(uint16_t y, uint16_t fc, uint16_t bc,
                   uint8_t *str, uint8_t size, uint8_t mode)
{
    uint16_t len = (uint16_t)strlen((const char*)str);
    uint8_t step = (size == 12) ? 6 : 8;
    uint16_t pixw = (uint16_t)(len * step);
    uint16_t x = 0;
    if (LCD_Width() > pixw) x = (uint16_t)((LCD_Width() - pixw) / 2U);

    uint16_t old_fc = POINT_COLOR, old_bc = BACK_COLOR;
    POINT_COLOR = fc; BACK_COLOR = bc;
    LCD_ShowString(x, y, size, str, mode);
    POINT_COLOR = old_fc; BACK_COLOR = old_bc;
}
