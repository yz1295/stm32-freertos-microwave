/**
  ******************************************************************************
  * @file    font.c
  * @brief   Font table builder + lookups for ASCII and Chinese glyphs
  ******************************************************************************/
#include "font.h"
#include <stddef.h>
#include <string.h>

/* Master 8x16 font (MIT-licensed) — you must add font8x16.c that defines this */
#include "font8x16.h"   /* extern const uint8_t font8x16[256][16]; */

/* ===== Runtime-built ASCII tables (populated by Font_Init) ===== */
unsigned char asc2_1206[95][12];  /* 6x12 cropped from 8x16 */
unsigned char asc2_1608[95][16];  /* direct copy of 8x16 (ASCII 32..126) */

/* ===== Chinese fonts — keep empty unless you paste real glyphs ===== */
const typFNT_GB16 tfont16[] = { /* empty */ };
const typFNT_GB24 tfont24[] = { /* empty */ };
const typFNT_GB32 tfont32[] = { /* empty */ };
const uint32_t tfont16_count = (uint32_t)(sizeof(tfont16)/sizeof(tfont16[0]));
const uint32_t tfont24_count = (uint32_t)(sizeof(tfont24)/sizeof(tfont24[0]));
const uint32_t tfont32_count = (uint32_t)(sizeof(tfont32)/sizeof(tfont32[0]));

/* ----------------------------------------------------------------------------
 * Helpers
 * ----------------------------------------------------------------------------*/
static inline int is_printable_ascii(char c) {
    return (c >= 32 && c <= 126);
}
static inline int idx_from_ascii(char c) {
    return (int)(c - 32);  /* tables are offset by 32 */
}

/* ----------------------------------------------------------------------------
 * Build-time init: map 8x16 master -> 8x16 subset and 6x12 cropped
 * ----------------------------------------------------------------------------*/
void Font_Init(void)
{
    /* Build 8x16 ASCII subset for ' '..'~' */
    for (int c = 32; c <= 126; ++c) {
        for (int row = 0; row < 16; ++row) {
            asc2_1608[c - 32][row] = font8x16[(uint8_t)c][row];
        }
    }

    /* Build 6x12 from 8x16 by cropping:
       - Keep top 12 rows
       - Keep left 6 columns (bits 7..2), zero out bits 1..0
       This matches your MSB-first renderer that only tests 6 columns.
    */
    for (int c = 32; c <= 126; ++c) {
        for (int row = 0; row < 12; ++row) {
            uint8_t b = font8x16[(uint8_t)c][row]; /* take row 0..11 */
            asc2_1206[c - 32][row] = (uint8_t)(b & 0xFC); /* zero out rightmost 2 bits */
        }
    }
}

/* ----------------------------------------------------------------------------
 * Public getters used by GUI
 * ----------------------------------------------------------------------------*/
const uint8_t* FONT_GetASCIIFont6x12(char c)
{
    if (!is_printable_ascii(c)) return NULL;
    return asc2_1206[idx_from_ascii(c)];
}

const uint8_t* FONT_GetASCIIFont8x16(char c)
{
    if (!is_printable_ascii(c)) return NULL;
    return asc2_1608[idx_from_ascii(c)];
}

/* ----------------------------------------------------------------------------
 * Chinese glyph lookups (no-op until you populate tfontXX)
 * ----------------------------------------------------------------------------*/
static const void* find_glyph_2byte(const void *table,
                                    uint32_t count,
                                    size_t record_size,
                                    size_t index_offset,
                                    const uint8_t index[2])
{
    const uint8_t *p = (const uint8_t*)table;
    for (uint32_t i = 0; i < count; ++i, p += record_size) {
        if (p[index_offset] == index[0] && p[index_offset+1] == index[1]) {
            return (const void*)p;
        }
    }
    return NULL;
}

const typFNT_GB16* FONT_GetChinese16(const uint8_t index[2])
{
    if (!index) return NULL;
    return (const typFNT_GB16*)find_glyph_2byte(tfont16, tfont16_count,
                                               sizeof(typFNT_GB16), 0, index);
}
const typFNT_GB24* FONT_GetChinese24(const uint8_t index[2])
{
    if (!index) return NULL;
    return (const typFNT_GB24*)find_glyph_2byte(tfont24, tfont24_count,
                                               sizeof(typFNT_GB24), 0, index);
}
const typFNT_GB32* FONT_GetChinese32(const uint8_t index[2])
{
    if (!index) return NULL;
    return (const typFNT_GB32*)find_glyph_2byte(tfont32, tfont32_count,
                                               sizeof(typFNT_GB32), 0, index);
}

